--- original-gcc/config.sub
+++ gcc/config.sub
@@ -340,6 +340,9 @@ case $basic_machine in
 	ms1)
 		basic_machine=mt-unknown
 		;;
+	riscv)
+		basic_machine=riscv-ucb
+		;;
 
 	strongarm | thumb | xscale)
 		basic_machine=arm-unknown
--- original-gcc/gcc/config.gcc
+++ gcc/gcc/config.gcc
@@ -439,6 +439,10 @@ powerpc*-*-*)
 	esac
 	extra_options="${extra_options} g.opt fused-madd.opt rs6000/rs6000-tables.opt"
 	;;
+riscv*)
+	cpu_type=riscv
+	need_64bit_hwint=yes
+	;;
 rs6000*-*-*)
 	extra_options="${extra_options} g.opt fused-madd.opt rs6000/rs6000-tables.opt"
 	;;
@@ -1976,6 +1980,34 @@ microblaze*-*-elf)
 	cxx_target_objs="${cxx_target_objs} microblaze-c.o"
 	tmake_file="${tmake_file} microblaze/t-microblaze"
         ;;
+riscv32*-*-linux*)
+	tm_file="elfos.h gnu-user.h linux.h glibc-stdint.h riscv/default-32.h ${tm_file} riscv/linux.h riscv/linux64.h"
+	tmake_file="${tmake_file} riscv/t-linux64"
+	gnu_ld=yes
+	gas=yes
+	gcc_cv_initfini_array=yes
+	;;
+riscv*-*-linux*)
+	tm_file="elfos.h gnu-user.h linux.h glibc-stdint.h ${tm_file} riscv/linux.h riscv/linux64.h"
+	tmake_file="${tmake_file} riscv/t-linux64"
+	gnu_ld=yes
+	gas=yes
+	gcc_cv_initfini_array=yes
+	;;
+riscv32*-*-elf*)
+	tm_file="elfos.h newlib-stdint.h riscv/default-32.h ${tm_file} riscv/elf.h"
+	tmake_file="${tmake_file} riscv/t-elf"
+	gnu_ld=yes
+	gas=yes
+	gcc_cv_initfini_array=yes
+	;;
+riscv*-*-elf*)
+	tm_file="elfos.h newlib-stdint.h ${tm_file} riscv/elf.h"
+	tmake_file="${tmake_file} riscv/t-elf"
+	gnu_ld=yes
+	gas=yes
+	gcc_cv_initfini_array=yes
+	;;
 mips*-*-netbsd*)			# NetBSD/mips, either endian.
 	target_cpu_default="MASK_ABICALLS"
 	tm_file="elfos.h ${tm_file} mips/elf.h netbsd.h netbsd-elf.h mips/netbsd.h"
@@ -3860,6 +3892,31 @@ case "${target}" in
 		done
 		;;
 
+	riscv*-*-*)
+		supported_defaults="abi arch arch_32 arch_64 float tune tune_32 tune_64"
+
+		case ${with_float} in
+		"" | soft | hard)
+			# OK
+			;;
+		*)
+			echo "Unknown floating point type used in --with-float=$with_float" 1>&2
+			exit 1
+			;;
+		esac
+
+		case ${with_abi} in
+		"" | 32 | 64)
+			# OK
+			;;
+		*)
+			echo "Unknown ABI used in --with-abi=$with_abi" 1>&2
+			exit 1
+			;;
+		esac
+
+    ;;
+
 	mips*-*-*)
 		supported_defaults="abi arch arch_32 arch_64 float fpu nan fp_32 odd_spreg_32 tune tune_32 tune_64 divide llsc mips-plt synci"
 
--- original-gcc/gcc/configure
+++ gcc/gcc/configure
@@ -23717,6 +23717,25 @@ x3:	.space 4
 	tls_first_minor=14
 	tls_as_opt="-a32 --fatal-warnings"
 	;;
+  riscv*-*-*)
+    conftest_s='
+	.section .tdata,"awT",@progbits
+x:
+	.word 2
+	.text
+	la.tls.gd a0,x
+	la.tls.ie a1,x
+	lui a0,%tls_ie_pcrel_hi(x)
+	lw a0,%pcrel_lo(x)(a0)
+	add a0,a0,tp
+	lw a0,0(a0)
+	lui a0,%tprel_hi(x)
+	add a0,a0,tp,%tprel_add(x)
+	lw a0,%tprel_lo(x)(a0)'
+	tls_first_major=2
+	tls_first_minor=21
+	tls_as_opt='-m32 --fatal-warnings'
+	;;
   s390-*-*)
     conftest_s='
 	.section ".tdata","awT",@progbits
--- original-gcc/gcc/configure.ac
+++ gcc/gcc/configure.ac
@@ -3263,6 +3263,25 @@ x3:	.space 4
 	tls_first_minor=14
 	tls_as_opt="-a32 --fatal-warnings"
 	;;
+  riscv*-*-*)
+    conftest_s='
+	.section .tdata,"awT",@progbits
+x:
+	.word 2
+	.text
+	la.tls.gd a0,x
+	la.tls.ie a1,x
+	lui a0,%tls_ie_pcrel_hi(x)
+	lw a0,%pcrel_lo(x)(a0)
+	add a0,a0,tp
+	lw a0,0(a0)
+	lui a0,%tprel_hi(x)
+	add a0,a0,tp,%tprel_add(x)
+	lw a0,%tprel_lo(x)(a0)'
+	tls_first_major=2
+	tls_first_minor=21
+	tls_as_opt='-m32 --fatal-warnings'
+	;;
   s390-*-*)
     conftest_s='
 	.section ".tdata","awT",@progbits
--- original-gcc/gcc/final.c
+++ gcc/gcc/final.c
@@ -232,6 +232,174 @@
 /* True if profile_function should be called, but hasn't been called yet.  */
 static bool need_profile_function;
 
+class dover_meta_data_label_t {
+ public:
+ dover_meta_data_label_t(const char *prefix) : prefix(prefix), labelno(label_counter++) { }
+ dover_meta_data_label_t(dover_meta_data_label_t const &r) : prefix(r.prefix), labelno(r.labelno) { }
+  void render(FILE *stream) const {
+    fprintf(stream, "%s%d", prefix, labelno);
+  }
+  void render_as_target(FILE *stream) {
+    render(stream);
+    fprintf(stream, ":\n");
+  }
+ private:
+  static int label_counter;
+  const char *prefix;
+  int labelno;
+};
+
+int dover_meta_data_label_t::label_counter = 0;
+
+#define DMD_SET_BASE_ADDRESS_OP 1u
+#define DMD_TAG_ADDRESS_OP 2u
+#define DMD_TAG_ADDRESS_RANGE_OP 3u
+#define DMD_END_BLOCK 8u
+#define DMD_END_BLOCK_WEAK_DECL_HACK 9u
+
+#define DMT_CFI3L_VALID_TGT 1u
+#define DMT_STACK_PROLOGUE_AUTHORITY 2u
+#define DMT_STACK_EPILOGUE_AUTHORITY 3u
+
+class dmd_renderer_t {
+  FILE *fp;
+  const char *fnname;
+ public:
+  void render_unsigned(unsigned v) {
+#ifdef HAVE_AS_LEB128
+    fprintf(fp, "\t.uleb128 %d\n", v);
+#else
+    fprintf(fp, "\t.byte %d\n", v);
+#endif
+  }
+  
+  void render_unsigned32(unsigned v) {
+    fprintf(fp, "\t.word %d\n", v);
+  }
+  
+  void render_base_op(unsigned op) {
+    render_unsigned(op);
+  }
+
+  void render_tag(unsigned tag) {
+    render_unsigned(tag);
+  }
+  
+  void render_fn_relative_offset(dover_meta_data_label_t const *label) {
+#if 0
+#ifdef HAVE_AS_LEB128
+    fprintf(fp, "\t.uleb128 ");
+#else
+    fprintf(fp, "\t.word ");
+#endif
+    label->render(fp);
+    fprintf(fp, " - %s\n", fnname);
+#else
+    fprintf(fp, ".set .L_DMD_SIZE_");
+    label->render(fp);
+    fprintf(fp, ", ");
+    label->render(fp);
+    fprintf(fp, " - %s\n", fnname);
+    fprintf(fp, "\t.word .L_DMD_SIZE_");
+    label->render(fp);
+    fprintf(fp, "\n");
+#endif
+  }
+
+  void start_function(FILE *fp) {
+    this->fp = fp;
+    
+    // set the base address for subsequent ops
+    render_base_op(DMD_SET_BASE_ADDRESS_OP);
+    fnname = get_fnname_from_decl (current_function_decl);
+    fprintf(fp, "\t.dword %s\n", fnname);
+  }
+
+  void end_function(FILE *fp, dover_meta_data_label_t const *l) {
+    if (l) {
+      render_base_op(DMD_END_BLOCK);
+      render_fn_relative_offset(l);
+    } else {
+      render_base_op(DMD_END_BLOCK_WEAK_DECL_HACK);
+      fprintf(fp, "\t.asciz\t\"%s\"\n", get_fnname_from_decl (current_function_decl));
+    }
+#if 0
+    fprintf(fp, "\t.dword\t");
+    l->render(fp);
+    fnname = get_fnname_from_decl (current_function_decl);
+    fprintf(fp, " - %s\n", fnname);
+#endif
+  }
+};
+
+class dover_meta_data_op_t {
+ public:
+  virtual void render(dmd_renderer_t *r) = 0;
+};
+
+class dmd_point_op_t : public dover_meta_data_op_t {
+ public:
+ dmd_point_op_t(dover_meta_data_label_t *addr) : addr(addr) { }
+  ~dmd_point_op_t() { delete addr; }
+ protected:
+  dover_meta_data_label_t *addr;
+};
+
+class dmd_ranged_op_t : public dover_meta_data_op_t {
+ protected:
+  dover_meta_data_label_t *start;
+  dover_meta_data_label_t *end;
+ public:
+  void set_start(dover_meta_data_label_t *l) { start = l; }
+  void set_end(dover_meta_data_label_t *l) { end = l; }
+};
+
+class dmdop_func_start_t : public dover_meta_data_op_t {
+ public:
+  void render(dmd_renderer_t *r) {
+    // function start is a valid CFI target
+    r->render_base_op(DMD_TAG_ADDRESS_OP);
+    r->render_unsigned32(0); // FIXME - should be uleb128, but we are stuck for now
+    r->render_tag(DMT_CFI3L_VALID_TGT);
+  }
+};
+
+class dmdop_prologue_auth_t : public dmd_ranged_op_t {
+ public:
+  void render(dmd_renderer_t *r) {
+    r->render_base_op( DMD_TAG_ADDRESS_RANGE_OP);
+    r->render_fn_relative_offset(start);
+    r->render_fn_relative_offset(end);
+    r->render_tag(DMT_STACK_PROLOGUE_AUTHORITY);
+  }
+};
+
+class dmdop_epilogue_auth_t : public dmd_ranged_op_t {
+ public:
+  void render(dmd_renderer_t *r) {
+    r->render_base_op( DMD_TAG_ADDRESS_RANGE_OP);
+    r->render_fn_relative_offset(start);
+    r->render_fn_relative_offset(end);
+    r->render_tag(DMT_STACK_EPILOGUE_AUTHORITY);
+  }
+};
+
+class dmdop_cfi_tgt_t : public dmd_point_op_t {
+ public:
+ dmdop_cfi_tgt_t(dover_meta_data_label_t *l) : dmd_point_op_t(l) { }
+  void render(dmd_renderer_t *r) {
+    r->render_base_op(DMD_TAG_ADDRESS_OP);
+    r->render_fn_relative_offset(addr);
+    r->render_tag(DMT_CFI3L_VALID_TGT);
+  }
+};
+
+dmdop_prologue_auth_t *dmd_prologue_authority;
+dmdop_epilogue_auth_t *dmd_epilogue_authority;
+bool past_prologue;
+
+static vec<dover_meta_data_op_t *> dover_meta_data_ops;
+
 static int asm_insn_count (rtx);
 static void profile_function (FILE *);
 static void profile_after_prologue (FILE *);
@@ -1777,6 +1945,111 @@
   return 0;
 }
 
+static void
+cfi_3tag_mark_source_instruction(FILE *stream, int is_target)
+{
+}
+
+static void
+cfi_3tag_mark_target_instruction(FILE *stream)
+{
+  dover_meta_data_label_t *l = new dover_meta_data_label_t(".Lcfi3t_tgt__");
+  l->render_as_target(stream);
+  dmdop_cfi_tgt_t *op = new dmdop_cfi_tgt_t(l);
+  dover_meta_data_ops.safe_push(op);
+  //  info.render(stdout);
+  //  printf("\n");
+}
+
+static void
+stack_policy_note_prologue_inst(FILE *stream) {
+  if (!dmd_prologue_authority) {
+    dmd_prologue_authority = new dmdop_prologue_auth_t();
+    dover_meta_data_label_t *l = new dover_meta_data_label_t(".Lstack_policy_prologue_");
+    l->render_as_target(stream);
+    dmd_prologue_authority->set_start(l);
+    dover_meta_data_ops.safe_push(dmd_prologue_authority);
+  }
+}
+
+static void
+stack_policy_note_non_prologue_inst(FILE *stream) {
+  if (dmd_prologue_authority) {
+    dover_meta_data_label_t *l = new dover_meta_data_label_t(".Lstack_policy_prologue_");
+    l->render_as_target(stream);
+    dmd_prologue_authority->set_end(l);
+    dmd_prologue_authority = NULL;
+  }
+}
+
+static void
+stack_policy_mark_end_prologue(FILE *stream)
+{
+  stack_policy_note_non_prologue_inst(stream);
+}
+
+static void
+stack_policy_note_epilogue_inst(FILE *stream) {
+  if (!dmd_epilogue_authority) {
+    dmd_epilogue_authority = new dmdop_epilogue_auth_t();
+    dover_meta_data_label_t *l = new dover_meta_data_label_t(".Lstack_policy_epilogue_");
+    l->render_as_target(stream);
+    dmd_epilogue_authority->set_start(l);
+    dover_meta_data_ops.safe_push(dmd_epilogue_authority);
+  }
+}
+
+static void
+stack_policy_note_non_epilogue_inst(FILE *stream) {
+  if (dmd_epilogue_authority) {
+    dover_meta_data_label_t *l = new dover_meta_data_label_t(".Lstack_policy_epilogue_");
+    l->render_as_target(stream);
+    dmd_epilogue_authority->set_end(l);
+    dmd_epilogue_authority = NULL;
+  }
+}
+
+static int next_insn_is_target = 0;
+static void
+cfi_3tag_internal_label(FILE *stream, const char *prefix, long labelno)
+{
+  cfi_3tag_mark_target_instruction(stream);
+  next_insn_is_target = 0;
+}
+
+dmd_renderer_t dmd_renderer;
+
+static void
+flush_dover_meta_data(FILE *stream)
+{
+  gcc_assert(!dmd_prologue_authority);
+  // make sure that the epilogue gets closed out
+  stack_policy_note_non_epilogue_inst(asm_out_file);
+//  dover_meta_data_label_t *l = NULL;
+//  if (!DECL_WEAK (current_function_decl)) {
+//    l = new dover_meta_data_label_t(".Ldmd_end_function_");
+//    l->render_as_target(stream);
+//  }
+  dover_meta_data_label_t *l = new dover_meta_data_label_t(".Ldmd_end_function_");
+  l->render_as_target(stream);
+  
+  switch_to_section (text_meta_data_section);
+  
+  dmd_renderer.start_function(stream);
+  dmdop_func_start_t func_start;
+
+  func_start.render(&dmd_renderer);
+  unsigned ix;
+  dover_meta_data_op_t *op;
+  FOR_EACH_VEC_ELT(dover_meta_data_ops, ix, op)
+  {
+    op->render(&dmd_renderer);
+  }
+
+  dmd_renderer.end_function(stream, l);
+  switch_to_section (current_function_section ());
+}
+
 /* Output assembler code for the start of a function,
    and initialize some of the variables in this file
    for the new function.  The label for the function and associated
@@ -1787,6 +2060,8 @@
    OPTIMIZE_P is nonzero if we should eliminate redundant
      test and compare insns.  */
 
+extern void dump_frame_info(FILE *file);
+
 void
 final_start_function (rtx_insn *first, FILE *file,
 		      int optimize_p ATTRIBUTE_UNUSED)
@@ -1803,6 +2078,10 @@
 
   high_block_linenum = high_function_linenum = last_linenum;
 
+  //  dump_frame_info(file);
+  dover_meta_data_ops.create(0);
+  past_prologue = false;
+  
   if (flag_sanitize & SANITIZE_ADDRESS)
     asan_function_start ();
 
@@ -1817,6 +2096,8 @@
     leaf_renumber_regs (first);
 #endif
 
+  next_insn_is_target = 0;
+
   /* The Sun386i and perhaps other machines don't work right
      if the profiling code comes after the prologue.  */
   if (targetm.profile_before_prologue () && crtl->profile)
@@ -1880,6 +2161,8 @@
   /* First output the function prologue: code to set up the stack frame.  */
   targetm.asm_out.function_prologue (file, get_frame_size ());
 
+  //  stack_policy_mark_end_prologue(file);
+
   /* If the machine represents the prologue as RTL, the profiling code must
      be emitted when NOTE_INSN_PROLOGUE_END is scanned.  */
 #ifdef HAVE_prologue
@@ -1964,6 +2247,9 @@
     dwarf2out_end_epilogue (last_linenum, last_filename);
 
   some_local_dynamic_name = 0;
+  ASM_OUTPUT_ALIGN(asm_out_file, 3);
+  flush_dover_meta_data(asm_out_file);
+  dover_meta_data_ops.release();
 }
 
 
@@ -2212,6 +2498,17 @@
   if (insn->deleted ())
     return NEXT_INSN (insn);
 
+  if (RTX_FRAME_RELATED_P (insn))
+    if (past_prologue)
+      stack_policy_note_epilogue_inst(asm_out_file);
+    else
+      stack_policy_note_prologue_inst(asm_out_file);
+  else
+    if (past_prologue)
+      stack_policy_note_non_epilogue_inst(asm_out_file);
+    else
+      stack_policy_note_non_prologue_inst(asm_out_file);
+
   switch (GET_CODE (insn))
     {
     case NOTE:
@@ -2268,6 +2565,8 @@
 	  break;
 
 	case NOTE_INSN_PROLOGUE_END:
+	  //	  stack_policy_mark_end_prologue(file);
+	  past_prologue = true;
 	  targetm.asm_out.function_end_prologue (file);
 	  profile_after_prologue (file);
 
@@ -2478,16 +2777,23 @@
 #ifdef ASM_OUTPUT_CASE_LABEL
 	  ASM_OUTPUT_CASE_LABEL (file, "L", CODE_LABEL_NUMBER (insn),
 				 next);
+	  if (in_section->common.flags & SECTION_CODE)
+	    cfi_3tag_internal_label(file, "L", CODE_LABEL_NUMBER(insn));
 #else
 	  targetm.asm_out.internal_label (file, "L", CODE_LABEL_NUMBER (insn));
 #endif
 #endif
 	  break;
 	}
-      if (LABEL_ALT_ENTRY_P (insn))
+      if (LABEL_ALT_ENTRY_P (insn)) {
+	//	printf("alt entry\n");
 	output_alternate_entry_point (file, insn);
+      }
       else
-	targetm.asm_out.internal_label (file, "L", CODE_LABEL_NUMBER (insn));
+	{
+	  cfi_3tag_internal_label(file, "L", CODE_LABEL_NUMBER(insn));
+	  targetm.asm_out.internal_label (file, "L", CODE_LABEL_NUMBER (insn));
+        }
       break;
 
     default:
@@ -2979,11 +3285,20 @@
 
 	NOTICE_UPDATE_CC (body, insn);
 #endif
+	if (JUMP_P(insn) || CALL_P(insn)) {
+	  cfi_3tag_mark_source_instruction(file, next_insn_is_target);
+	  next_insn_is_target = 1;
+	} else if (next_insn_is_target) {
+	  cfi_3tag_mark_target_instruction(file);
+	  next_insn_is_target = 0;
+	}
 
 	current_output_insn = debug_insn = insn;
 
 	/* Find the proper template for this insn.  */
 	templ = get_insn_template (insn_code_number, insn);
+	//	if (templ)
+	//	  printf("templ = '%s'\n", templ);
 
 	/* If the C code returns 0, it means that it is a jump insn
 	   which follows a deleted test insn, and that test insn
--- original-gcc/gcc/output.h
+++ gcc/gcc/output.h
@@ -506,6 +506,7 @@
 struct object_block;
 
 /* Special well-known sections.  */
+extern GTY(()) section *text_meta_data_section;
 extern GTY(()) section *text_section;
 extern GTY(()) section *data_section;
 extern GTY(()) section *readonly_data_section;
--- original-gcc/gcc/varasm.c
+++ gcc/gcc/varasm.c
@@ -150,6 +150,7 @@
 static void mark_weak (tree);
 static void output_constant_pool (const char *, tree);
 
+section *text_meta_data_section;
 /* Well-known sections, each one associated with some sort of *_ASM_OP.  */
 section *text_section;
 section *data_section;
@@ -6101,6 +6102,9 @@
 					       emit_bss);
 #endif
 
+  text_meta_data_section = get_unnamed_section (0, output_section_asm_op,
+					       "\t.section\t.dover_metadata, \"a\"");
+
   targetm.asm_out.init_sections ();
 
   if (readonly_data_section == NULL)
--- original-gcc/gcc/testsuite/gcc.c-torture/execute/20101011-1.c
+++ gcc/gcc/testsuite/gcc.c-torture/execute/20101011-1.c
@@ -6,6 +6,9 @@
 #elif defined (__powerpc__) || defined (__PPC__) || defined (__ppc__) || defined (__POWERPC__) || defined (__ppc)
   /* On PPC division by zero does not trap.  */
 # define DO_TEST 0
+#elif defined (__riscv__)
+  /* On RISC-V division by zero does not trap.  */
+# define DO_TEST 0
 #elif defined (__SPU__)
   /* On SPU division by zero does not trap.  */
 # define DO_TEST 0
--- original-gcc/gcc/testsuite/gcc.dg/20020312-2.c
+++ gcc/gcc/testsuite/gcc.dg/20020312-2.c
@@ -66,6 +66,8 @@ extern void abort (void);
 # else
 #  define PIC_REG  "30"
 # endif
+#elif defined(__riscv__)
+/* No pic register.  */
 #elif defined(__RX__)
 /* No pic register.  */
 #elif defined(__s390__)
--- original-gcc/gcc/testsuite/gcc.dg/20040813-1.c
+++ gcc/gcc/testsuite/gcc.dg/20040813-1.c
@@ -2,7 +2,7 @@
 /* Contributed by Devang Patel  <dpatel@apple.com>  */
 
 /* { dg-do compile } */
-/* { dg-skip-if "No stabs" { aarch64*-*-* mmix-*-* *-*-aix* alpha*-*-* hppa*64*-*-* ia64-*-* tile*-*-* nios2-*-* *-*-vxworks* nvptx-*-* } { "*" } { "" } } */
+/* { dg-skip-if "No stabs" { aarch64*-*-* mmix-*-* *-*-aix* alpha*-*-* hppa*64*-*-* ia64-*-* riscv*-*-* tile*-*-* nios2-*-* *-*-vxworks* nvptx-*-* } { "*" } { "" } } */
 /* { dg-options "-gstabs" } */
 
 int
--- original-gcc/gcc/testsuite/gcc.dg/stack-usage-1.c
+++ gcc/gcc/testsuite/gcc.dg/stack-usage-1.c
@@ -61,6 +61,8 @@
 #  else
 #    define SIZE 240
 #  endif
+#elif defined (__riscv__)
+#  define SIZE 240
 #elif defined (__AVR__)
 #  define SIZE 254
 #elif defined (__s390x__)
--- original-gcc/libatomic/configure.tgt
+++ gcc/libatomic/configure.tgt
@@ -33,6 +33,7 @@ case "${target_cpu}" in
 	ARCH=alpha
 	;;
   rs6000 | powerpc*)	ARCH=powerpc ;;
+  riscv*)		ARCH=riscv ;;
   sh*)			ARCH=sh ;;
 
   arm*)
--- original-gcc/libgcc/config.host
+++ gcc/libgcc/config.host
@@ -167,6 +167,9 @@ powerpc*-*-*)
 	;;
 rs6000*-*-*)
 	;;
+riscv*)
+	cpu_type=riscv
+	;;
 sparc64*-*-*)
 	cpu_type=sparc
 	;;
@@ -1059,6 +1062,18 @@ powerpcle-*-eabi*)
 	tmake_file="${tmake_file} rs6000/t-ppccomm rs6000/t-crtstuff t-crtstuff-pic t-fdpbit"
 	extra_parts="$extra_parts crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o ecrti.o ecrtn.o ncrti.o ncrtn.o"
 	;;
+riscv32*-*-linux*)
+	tmake_file="${tmake_file} riscv/t-fpbit riscv/t-dpbit riscv/t-tpbit riscv/t-elf riscv/t-elf32"
+	extra_parts="$extra_parts crtbegin.o crtend.o crti.o crtn.o crtendS.o crtbeginT.o"
+	;;
+riscv*-*-linux*)
+	tmake_file="${tmake_file} riscv/t-fpbit riscv/t-dpbit riscv/t-tpbit riscv/t-elf"
+	extra_parts="$extra_parts crtbegin.o crtend.o crti.o crtn.o crtendS.o crtbeginT.o"
+	;;
+riscv*-*-*)
+	tmake_file="${tmake_file} riscv/t-fpbit riscv/t-dpbit riscv/t-elf"
+	extra_parts="$extra_parts crtbegin.o crtend.o crti.o crtn.o"
+	;;
 rs6000-ibm-aix4.[3456789]* | powerpc-ibm-aix4.[3456789]*)
 	md_unwind_header=rs6000/aix-unwind.h
 	tmake_file="t-fdpbit rs6000/t-ppc64-fp rs6000/t-slibgcc-aix rs6000/t-ibm-ldouble"
--- original-gcc/libsanitizer/asan/asan_linux.cc
+++ gcc/libsanitizer/asan/asan_linux.cc
@@ -213,6 +213,11 @@ void GetPcSpBp(void *context, uptr *pc,
   *pc = ucontext->uc_mcontext.gregs[31];
   *bp = ucontext->uc_mcontext.gregs[30];
   *sp = ucontext->uc_mcontext.gregs[29];
+# elif defined(__riscv__)
+  ucontext_t *ucontext = (ucontext_t*)context;
+  *pc = ucontext->uc_mcontext.gregs[REG_PC];
+  *bp = ucontext->uc_mcontext.gregs[REG_S0];
+  *sp = ucontext->uc_mcontext.gregs[REG_SP];
 #else
 # error "Unsupported arch"
 #endif
--- original-gcc/libsanitizer/sanitizer_common/sanitizer_platform_limits_linux.cc
+++ gcc/libsanitizer/sanitizer_common/sanitizer_platform_limits_linux.cc
@@ -61,7 +61,8 @@ namespace __sanitizer {
 }  // namespace __sanitizer
 
 #if !defined(__powerpc64__) && !defined(__x86_64__) && !defined(__aarch64__)\
-                            && !defined(__mips__) && !defined(__sparc__)
+                            && !defined(__mips__) && !defined(__sparc__)\
+                            && !defined(__riscv__)
 COMPILER_CHECK(struct___old_kernel_stat_sz == sizeof(struct __old_kernel_stat));
 #endif
 
--- original-gcc/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h
+++ gcc/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h
@@ -72,6 +72,10 @@ namespace __sanitizer {
   const unsigned struct_kernel_stat_sz = 144;
   #endif
   const unsigned struct_kernel_stat64_sz = 104;
+#elif defined(__riscv__)
+  const unsigned struct___old_kernel_stat_sz = 0;
+  const unsigned struct_kernel_stat_sz = 128;
+  const unsigned struct_kernel_stat64_sz = 128;
 #elif defined(__sparc__) && defined(__arch64__)
   const unsigned struct___old_kernel_stat_sz = 0;
   const unsigned struct_kernel_stat_sz = 104;
@@ -511,7 +515,7 @@ namespace __sanitizer {
   typedef long __sanitizer___kernel_off_t;
 #endif
 
-#if defined(__powerpc__) || defined(__mips__)
+#if defined(__powerpc__) || defined(__mips__) || defined(__riscv__)
   typedef unsigned int __sanitizer___kernel_old_uid_t;
   typedef unsigned int __sanitizer___kernel_old_gid_t;
 #else
diff -ru gcc-5.1.0.orig/libsanitizer/sanitizer_common/sanitizer_platform.h gcc-5.1.0/libsanitizer/sanitizer_common/sanitizer_platform.h
--- gcc-5.1.0.orig/libsanitizer/sanitizer_common/sanitizer_platform.h	2015-05-13 19:36:27.061421043 -0700
+++ gcc-5.1.0/libsanitizer/sanitizer_common/sanitizer_platform.h	2015-05-13 19:44:19.274355577 -0700
@@ -98,9 +98,9 @@
 
 // The AArch64 linux port uses the canonical syscall set as mandated by
 // the upstream linux community for all new ports. Other ports may still
-// use legacy syscalls.
+// use legacy syscalls.  The RISC-V port also does this.
 #ifndef SANITIZER_USES_CANONICAL_LINUX_SYSCALLS
-# if defined(__aarch64__) && SANITIZER_LINUX
+# if (defined(__aarch64__) || defined(__riscv__)) && SANITIZER_LINUX
 # define SANITIZER_USES_CANONICAL_LINUX_SYSCALLS 1
 # else
 # define SANITIZER_USES_CANONICAL_LINUX_SYSCALLS 0
diff -ru gcc-5.1.0.orig/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h gcc-5.1.0/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h
--- gcc-5.1.0.orig/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h	2015-05-13 19:36:27.061421043 -0700
+++ gcc-5.1.0/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h	2015-05-13 19:39:13.515487834 -0700
@@ -73,7 +73,6 @@
   #endif
   const unsigned struct_kernel_stat64_sz = 104;
 #elif defined(__riscv__)
-  const unsigned struct___old_kernel_stat_sz = 0;
   const unsigned struct_kernel_stat_sz = 128;
   const unsigned struct_kernel_stat64_sz = 128;
 #elif defined(__sparc__) && defined(__arch64__)
@@ -104,7 +103,7 @@
 
 #if SANITIZER_LINUX || SANITIZER_FREEBSD
 
-#if defined(__powerpc64__)
+#if defined(__powerpc64__) || defined(__riscv__)
   const unsigned struct___old_kernel_stat_sz = 0;
 #elif !defined(__sparc__)
   const unsigned struct___old_kernel_stat_sz = 32;
--- original-gcc/libstdc++-v3/configure
+++ gcc/libstdc++-v3/configure
@@ -16641,7 +16641,7 @@ ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
   # Long term, -std=c++0x could be even better, could manage to explicitly
   # request C99 facilities to the underlying C headers.
   ac_save_CXXFLAGS="$CXXFLAGS"
-  CXXFLAGS="$CXXFLAGS -std=c++98"
+  CXXFLAGS="$CXXFLAGS -std=gnu++98"
   ac_save_LIBS="$LIBS"
   ac_save_gcc_no_link="$gcc_no_link"
 
@@ -17263,9 +17263,11 @@ rm -f core conftest.err conftest.$ac_obj
 $as_echo "$glibcxx_cv_c99_wchar" >&6; }
   fi
 
+  # For newlib, don't check complex since missing c99 functions, but
+  #   rest of c99 stuff is there so don't loose it
   # Option parsed, now set things appropriately.
   if test x"$glibcxx_cv_c99_math" = x"no" ||
-     test x"$glibcxx_cv_c99_complex" = x"no" ||
+     # test x"$glibcxx_cv_c99_complex" = x"no" ||
      test x"$glibcxx_cv_c99_stdio" = x"no" ||
      test x"$glibcxx_cv_c99_stdlib" = x"no" ||
      test x"$glibcxx_cv_c99_wchar" = x"no"; then

